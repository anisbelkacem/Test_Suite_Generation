package de.uni_passau.fim.se2.sbse.suite_generation.utils;

import java.util.AbstractCollection;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;

import static java.util.Objects.hash;
import static java.util.Objects.requireNonNull;

/**
 * An immutable homogeneous container class to store two elements of the same type. The class
 * prohibits {@code null} elements.
 *
 * @param <T> the type of the elements in this pair
 * @author Sebastian Schweikl
 */
public final class Pair<T> extends AbstractCollection<T> {

    /**
     * The size of every pair.
     */
    private static final int size = 2;

    /**
     * The first element of this pair.
     */
    private final T fst;

    /**
     * The second element of this pair.
     */
    private final T snd;

    /**
     * Creates a new pair that contains the same elements as the given pair.
     *
     * @param copy the pair whose elements to place into the new pair, not {@code null}
     * @throws NullPointerException if the specified pair is {@code null}
     */
    public Pair(final Pair<? extends T> copy) {
        requireNonNull(copy);
        this.fst = copy.getFst();
        this.snd = copy.getSnd();
    }

    /**
     * Constructs a new pair from the given elements, neither of which is allowed to be {@code
     * null}.
     *
     * @param fst the first element, not {@code null}
     * @param snd the second element, not {@code null}
     * @throws NullPointerException if an argument is {@code null}
     */
    public Pair(final T fst, final T snd) {
        this.fst = requireNonNull(fst);
        this.snd = requireNonNull(snd);
    }

    /**
     * Creates a new pair containing the specified elements.
     *
     * @param fst the first component, not {@code null}
     * @param snd the second component, not {@code null}
     * @param <T> the type of the elements
     * @return a pair containing the specified elements
     * @throws NullPointerException if an argument is {@code null}
     * @apiNote Less verbose than calling the constructor directly ({@code new} keyword and diamond
     * operator not needed).
     */
    public static <T> Pair<T> of(final T fst, final T snd) {
        return new Pair<>(fst, snd);
    }

    /**
     * Returns a pair where each element is generated by the provided supplier. This is suitable for
     * generating constant pairs, pairs of random elements, etc.
     *
     * @param supplier the supplier of generated elements, not {@code null}
     * @param <T>      the element type of the pair
     * @return the generated pair
     * @throws NullPointerException if the {@code supplier} is {@code null}
     */
    public static <T> Pair<T> generate(final Supplier<T> supplier) {
        requireNonNull(supplier);
        return Pair.of(supplier.get(), supplier.get());
    }

    /**
     * Returns a reference to the first element of this pair.
     *
     * @return the first element
     */
    public T getFst() {
        return fst;
    }

    /**
     * Returns a reference to the second element of this pair.
     *
     * @return the second element
     */
    public T getSnd() {
        return snd;
    }

    /**
     * Returns the pair consisting of the results of applying the given mapper functions to the
     * elements of this pair.
     *
     * @param mapperFst the mapper to apply to the first element of this pair, not {@code null}
     * @param mapperSnd the mapper to apply to the second element of this pair, not {@code null}
     * @param <U>       the result type of mapping the elements
     * @return the mapped pair
     * @throws NullPointerException if an argument is {@code null}
     */
    public <U> Pair<U> map(
            final Function<? super T, U> mapperFst,
            final Function<? super T, U> mapperSnd) {
        requireNonNull(mapperFst);
        requireNonNull(mapperSnd);
        return Pair.of(mapperFst.apply(fst), mapperSnd.apply(snd));
    }

    /**
     * Returns the pair consisting of the results of applying the given mapper function to the
     * elements of this pair.
     *
     * @param mapper the mapper to apply to each element of this pair, not {@code null}
     * @param <U>    the result type of mapping an element, not {@code null}
     * @return the mapped pair
     * @throws NullPointerException if the {@code mapper} is {@code null}
     */
    public <U> Pair<U> map(final Function<? super T, U> mapper) {
        return map(mapper, mapper);
    }

    /**
     * Performs a reduction operation on this pair, using the supplied {@code combiner} function.
     *
     * @param combiner the function used to combine the two elements of this pair, not {@code null}
     * @param <U>      the result type
     * @return the result of the reduction.
     * @throws NullPointerException if the {@code combiner} is {@code null}
     */
    public <U> U reduce(final Function<Pair<? extends T>, U> combiner) {
        requireNonNull(combiner);
        return combiner.apply(this);
    }

    /**
     * Performs a reduction operation on the elements of this pair, using the supplied {@code
     * combiner} function.
     *
     * @param combiner the function used to combine the two elements of this pair, not {@code null}
     * @param <U>      the result type
     * @return the result of the reduction.
     * @throws NullPointerException if the {@code combiner} is {@code null}
     */
    public <U> U reduce(final BiFunction<? super T, ? super T, U> combiner) {
        requireNonNull(combiner);
        return combiner.apply(fst, snd);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Iterator<T> iterator() {
        return new Iterator<>() {
            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < size;
            }

            @Override
            public T next() {
                return switch (index++) {
                    case 0 -> fst;
                    case 1 -> snd;
                    default -> throw new NoSuchElementException();
                };
            }
        };
    }

    /**
     * Returns the number of elements in this collection, which is always 2.
     *
     * @return always 2
     */
    @Override
    public int size() {
        return size;
    }

    /**
     * Compares this pair to the given other pair for equality. To this, a component-wise equality
     * comparison is performed. Two pairs are considered equal if and only if their components are
     * equal. Also returns {@code false} if the given other pair is {@code null}.
     *
     * @param other the pair to compare to
     * @return {@code true} if the elements of the given pair are equal to this one, {@code false}
     * otherwise
     */
    @Override
    public boolean equals(final Object other) {
        if (this == other) {
            return true;
        }

        if (other == null || getClass() != other.getClass()) {
            return false;
        }

        final Pair<?> that = (Pair<?>) other;
        return (this.getFst()).equals(that.getFst()) && (this.getSnd()).equals(that.getSnd());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
        return hash(getFst(), getSnd());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
        return String.format("%s(%s, %s)", getClass().getSimpleName(), getFst(), getSnd());
    }
}
